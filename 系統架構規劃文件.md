# XMC4800 CANopen 系統架構規劃文件

## 1. 系統架構概覽

### 1.1 整體架構圖
```
┌─────────────────────────────────────────────────────────────┐
│                    應用層 (Application Layer)                 │
├─────────────────────────────────────────────────────────────┤
│                 CANopen 協定層 (CANopen Layer)                │
│  ┌───────────────┬───────────────┬───────────────────────┐   │
│  │   NMT/HB      │    SDO        │        PDO            │   │
│  │ (網路管理)     │ (服務資料)     │    (程序資料)          │   │
│  └───────────────┴───────────────┴───────────────────────┘   │
├─────────────────────────────────────────────────────────────┤
│                CANopenNode 2.0 函式庫                        │
├─────────────────────────────────────────────────────────────┤
│              CAN 驅動抽象層 (CAN Driver Abstraction)          │
├─────────────────────────────────────────────────────────────┤
│               XMC4800 CAN 硬體抽象層 (HAL)                   │
├─────────────────────────────────────────────────────────────┤
│                XMC4800 MultiCAN 硬體層                       │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 核心模組說明

#### 1.2.1 應用層
- **功能**：實現具體的業務邏輯
- **職責**：
  - 設備特定功能實現
  - 使用者介面處理
  - 設備狀態管理
  - 錯誤處理和診斷

#### 1.2.2 CANopen 協定層
- **NMT (Network Management)**
  - 節點狀態管理：Pre-operational, Operational, Stopped
  - 心跳監控
  - 節點重置功能
  
- **SDO (Service Data Object)**
  - 物件字典存取
  - 分段傳輸支援
  - 客戶端/伺服器通訊
  
- **PDO (Process Data Object)**
  - 實時資料交換
  - 事件驅動或同步傳輸
  - 映射配置管理

#### 1.2.3 CANopenNode 2.0 函式庫
- **CO_driver.c/h**：CAN 驅動介面
- **CO_OD.c/h**：物件字典實現
- **CO_NMT.c/h**：網路管理
- **CO_SDO.c/h**：服務資料物件
- **CO_PDO.c/h**：程序資料物件
- **CO_SYNC.c/h**：同步物件
- **CO_Emergency.c/h**：緊急物件

## 2. 硬體架構

### 2.1 XMC4800 硬體資源

#### 2.1.1 MultiCAN 模組特性
```
MultiCAN 控制器規格：
├── CAN 節點數量：3 個獨立節點 (Node 0, 1, 2)
├── 訊息物件：128 個 (每個節點最多 64 個)
├── 支援協定：CAN 2.0A (11-bit ID) 和 CAN 2.0B (29-bit ID)
├── 波特率範圍：10 kbps - 1 Mbps
├── FIFO 緩衝：硬體 FIFO 支援
└── 中斷功能：接收/傳送/錯誤中斷
```

#### 2.1.2 腳位配置
```
CAN Node 0 (建議使用)：
├── CAN0_TXD：P1.13 (替代功能 AF2)
├── CAN0_RXD：P1.12 (輸入腳位)
└── 外部收發器：需要連接 CAN 收發器 (如 TJA1050)

記憶體配置：
├── Flash：2048 KB (程式碼存儲)
├── RAM：352 KB (執行時記憶體)
└── EEPROM：模擬 (使用 Flash 分區)
```

### 2.2 CAN 收發器電路

#### 2.2.1 推薦電路設計
```
XMC4800          TJA1050          CAN 匯流排
┌─────────┐     ┌─────────┐      ┌──────────┐
│ CAN_TXD ├────→│ TXD     │      │   CANH   │
│ CAN_RXD │←────┤ RXD     │      │          │
│   3.3V  ├────→│ VCC     │      │   CANL   │
│   GND   ├────→│ GND     ├─────→│   GND    │
└─────────┘     │ CANH    ├─────→│          │
                │ CANL    ├─────→│          │
                └─────────┘      └──────────┘
```

## 3. 軟體架構詳細設計

### 3.1 檔案結構
```
XMC4800_CANopen/
├── src/
│   ├── main.c                  // 主程式進入點
│   ├── system_init.c          // 系統初始化
│   ├── can_driver/
│   │   ├── can_xmc4800.c      // XMC4800 CAN 驅動實現
│   │   ├── can_xmc4800.h      // CAN 驅動標頭檔
│   │   └── can_config.h       // CAN 配置參數
│   ├── canopen/
│   │   ├── CO_app.c           // CANopen 應用層
│   │   ├── CO_OD.c            // 物件字典實現
│   │   ├── CO_OD.h            // 物件字典標頭檔
│   │   └── CO_driver_target.h // 目標平台驅動標頭
│   ├── application/
│   │   ├── app_main.c         // 應用程式主邏輯
│   │   ├── device_profile.c   // 設備描述檔實現
│   │   └── diagnostics.c      // 診斷功能
│   └── utils/
│       ├── timer.c            // 定時器功能
│       ├── led.c              // LED 指示燈控制
│       └── debug.c            // 除錯功能
├── CANopenNode/               // Git submodule
│   ├── 301/                   // CANopen 標準實現
│   ├── 303/                   // 額外功能模組
│   └── example/               // 範例程式
├── Dave/
│   ├── Generated/             // DAVE 自動產生的檔案
│   └── Model/                 // DAVE 專案模型
├── linker/
│   └── XMC4800x2048.ld       // 連結器腳本
├── config/
│   ├── system_config.h        // 系統配置
│   ├── can_config.h          // CAN 配置
│   └── canopen_config.h      // CANopen 配置
└── docs/                     // 文件目錄
```

### 3.2 核心模組設計

#### 3.2.1 CAN 驅動模組 (can_xmc4800.c)
```c
/* 主要功能函數 */
typedef struct {
    CO_CANmodule_t *CANmodule;
    uint8_t nodeId;
    uint16_t CANbitRate;
    XMC_CAN_NODE_t *CANptr;
    XMC_CAN_MO_t *CANmsgBuff[CO_CAN_TX_BUFFER_SIZE];
    bool_t CANnormal;
    bool_t useCANrxFilters;
    bool_t bufferInhibitFlag;
    bool_t firstCANtxMessage;
    volatile bool_t CANtxBufferFull[CO_CAN_TX_BUFFER_SIZE];
    volatile uint16_t CANtxBufferCount;
} CO_CANmodule_XMC_t;

/* 核心介面函數 */
CO_ReturnError_t CO_CANmodule_init(
    CO_CANmodule_t *CANmodule,
    void *CANptr,
    CO_CANrx_t rxArray[],
    uint16_t rxSize,
    CO_CANtx_t txArray[],
    uint16_t txSize,
    uint16_t CANbitRate
);

CO_ReturnError_t CO_CANsend(CO_CANmodule_t *CANmodule, CO_CANtx_t *buffer);
void CO_CANclearPendingSyncPDOs(CO_CANmodule_t *CANmodule);
void CO_CANmodule_process(CO_CANmodule_t *CANmodule);
```

#### 3.2.2 物件字典設計 (CO_OD.c)
```c
/* 物件字典結構 */
typedef struct {
    uint16_t index;
    uint8_t subIndex;
    uint8_t attribute;
    uint16_t length;
    void *pData;
} OD_entry_t;

/* 標準物件字典項目 */
#define OD_H1000_DEV_TYPE          0x1000  // 設備類型
#define OD_H1001_ERR_REG           0x1001  // 錯誤暫存器
#define OD_H1002_MANUF_STATUS      0x1002  // 製造商狀態
#define OD_H1003_PREDEF_ERR        0x1003  // 預定義錯誤欄位
#define OD_H1005_COB_ID_SYNC       0x1005  // SYNC COB-ID
#define OD_H1006_COMM_CYCL_PERIOD  0x1006  // 通訊週期
#define OD_H1007_SYNC_WINDOW_LEN   0x1007  // 同步視窗長度
#define OD_H1008_MANUF_DEV_NAME    0x1008  // 製造商設備名稱
#define OD_H1009_MANUF_HW_VERSION  0x1009  // 製造商硬體版本
#define OD_H100A_MANUF_SW_VERSION  0x100A  // 製造商軟體版本
```

#### 3.2.3 應用層框架 (app_main.c)
```c
/* 應用程式狀態機 */
typedef enum {
    APP_STATE_INIT,
    APP_STATE_CANOPEN_INIT,
    APP_STATE_RUNNING,
    APP_STATE_ERROR,
    APP_STATE_RESET
} app_state_t;

/* 主要應用程式結構 */
typedef struct {
    app_state_t state;
    CO_t *CO;
    uint32_t timer1msPrevious;
    uint16_t timer1msToggle;
    uint8_t nodeId;
    uint16_t CANbitRate;
    bool emergencyTrigger;
} application_t;

/* 核心應用函數 */
void app_init(void);
void app_main_loop(void);
void app_process_canopen(void);
void app_process_application(void);
void app_handle_nmt_state_change(CO_NMT_internalState_t state);
```

### 3.3 系統初始化流程

#### 3.3.1 初始化順序
```c
int main(void) {
    // 1. 基礎系統初始化
    system_clock_init();
    gpio_init();
    uart_init();  // 用於除錯輸出
    
    // 2. CAN 硬體初始化
    can_hardware_init();
    
    // 3. CANopen 堆疊初始化
    canopen_stack_init();
    
    // 4. 應用程式初始化
    application_init();
    
    // 5. 啟動主迴圈
    while(1) {
        main_loop_process();
    }
}
```

#### 3.3.2 CAN 初始化配置
```c
/* CAN 配置參數 */
#define CAN_NODE_NUM        XMC_CAN_NODE_0
#define CAN_BITRATE_500K    500000U
#define CAN_SAMPLE_POINT    875  // 87.5%
#define CAN_SJW             1
#define CAN_TQ_PRESCALER    3

/* CAN 訊息物件配置 */
#define CAN_MO_RX_FIFO      0    // 接收 FIFO
#define CAN_MO_TX_BUFFER    1    // 傳送緩衝
#define CO_CAN_TX_BUFFER_SIZE   16
#define CO_CAN_RX_BUFFER_SIZE   16
```

### 3.4 中斷處理架構

#### 3.4.1 CAN 中斷處理
```c
/* CAN 接收中斷 */
void CAN0_0_IRQHandler(void) {
    CO_CANinterrupt(CO->CANmodule[0]);
}

/* 系統定時器中斷 (1ms) */
void SysTick_Handler(void) {
    CO_process_SYNC(CO, 1000);
    CO_process_RPDO(CO);
    CO_process_TPDO(CO);
    
    /* 應用程式定時處理 */
    app_1ms_timer_process();
}
```

#### 3.4.2 中斷優先級配置
```c
/* 中斷優先級設定 */
#define CAN_IRQ_PRIORITY        2   // CAN 中斷 (高優先級)
#define SYSTICK_IRQ_PRIORITY    3   // 系統定時器
#define UART_IRQ_PRIORITY       4   // UART 除錯 (低優先級)
```

## 4. 記憶體管理

### 4.1 記憶體分配策略
```c
/* 靜態記憶體分配 */
#define CO_OD_RAM_SIZE          2048    // 物件字典 RAM
#define CO_SDO_BUFFER_SIZE      128     // SDO 緩衝區
#define CO_PDO_RX_BUFFER_SIZE   8       // PDO 接收緩衝
#define CO_PDO_TX_BUFFER_SIZE   8       // PDO 傳送緩衝
#define APP_BUFFER_SIZE         512     // 應用程式緩衝

/* 堆疊大小配置 */
#define MAIN_STACK_SIZE         4096    // 主堆疊
#define ISR_STACK_SIZE          1024    // 中斷堆疊
```

### 4.2 Flash 分區規劃
```
Flash 記憶體分配 (2048 KB)：
├── Bootloader：        0x08000000 - 0x08007FFF (32 KB)
├── 應用程式：           0x08008000 - 0x081EFFFF (1984 KB)
├── 物件字典備份：       0x081F0000 - 0x081F7FFF (32 KB)
├── 參數儲存：          0x081F8000 - 0x081FBFFF (16 KB)
├── 日誌記錄：          0x081FC000 - 0x081FEFFF (12 KB)
└── 系統配置：          0x081FF000 - 0x081FFFFF (4 KB)
```

## 5. 效能最佳化策略

### 5.1 CAN 通訊最佳化
- **硬體 FIFO 使用**：充分利用 MultiCAN 的硬體 FIFO
- **中斷合併**：減少中斷頻率，提高系統效率
- **DMA 傳輸**：對於大量資料傳輸使用 DMA
- **訊息過濾**：使用硬體訊息過濾減少 CPU 負載

### 5.2 CANopen 協定最佳化
- **PDO 映射最佳化**：合理配置 PDO 映射減少頻寬使用
- **SDO 分段最佳化**：優化 SDO 分段傳輸效率
- **同步機制**：使用硬體定時器提高同步精度

### 5.3 應用程式最佳化
- **狀態機設計**：使用高效的狀態機實現
- **緩衝管理**：實現環形緩衝區提高資料處理效率
- **記憶體池**：使用記憶體池避免動態分配

## 6. 錯誤處理和診斷

### 6.1 錯誤分類
```c
typedef enum {
    ERR_NONE = 0,
    ERR_CAN_BUS_OFF,
    ERR_CAN_TX_OVERFLOW,
    ERR_CAN_RX_OVERFLOW,
    ERR_CANOPEN_SYNC_TIMEOUT,
    ERR_CANOPEN_HB_TIMEOUT,
    ERR_APP_PARAMETER_ERROR,
    ERR_SYSTEM_MEMORY_ERROR
} error_code_t;
```

### 6.2 診斷功能
- **LED 狀態指示**：通過 LED 顯示系統狀態
- **除錯輸出**：UART 除錯訊息輸出
- **錯誤記錄**：錯誤事件記錄到 Flash
- **系統監控**：看門狗和系統監控

## 7. 測試架構

### 7.1 單元測試
- CAN 驅動功能測試
- CANopen 協定層測試
- 物件字典操作測試

### 7.2 整合測試
- CAN 網路通訊測試
- 多節點互操作測試
- 壓力和可靠性測試

### 7.3 合規性測試
- CANopen 協定合規性
- CiA 認證測試準備

---

**文件版本**：v1.0  
**最後更新**：2025年8月21日  
**負責人**：MCU專業軟體工程師  
**審核狀態**：待審核