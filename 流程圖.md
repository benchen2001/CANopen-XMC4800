# 多 RX LMO 驅動核心流程 & 深度設計視覺化 (GitHub Mermaid 版)

版本: 2.0  
更新日期: 2025-08-30  
狀態: 擴充為完整 8 大流程 + 3 個序列圖 + 1 個狀態機 + 日誌事件對照。  

> 目標：精準、完備、工程落地可追溯。取代先前簡化版 1.0。專注「一件事做到好」：清晰呈現多 RX LMO 動態綁定與維護之所有關鍵節點、異常路徑與決策準則。

---
## 目錄
1. 圖例與符號說明  
2. 核心資料結構對照  
3. 流程 #1 初始化 (Init)  
4. 流程 #2 RX 緩衝註冊 (Register)  
5. 流程 #3 COB‑ID 變更排程 / 應用  
6. 流程 #4 綁定釋放與優先級提升  
7. 流程 #5 延遲維護與搶占  
8. 流程 #6 中斷分派 (ISR Dispatch)  
9. 流程 #7 Wildcard 評估與降級  
10. 流程 #8 錯誤 / 例外 / 防護  
11. 序列圖 A: 啟動 + 高優先級綁定  
12. 序列圖 B: 動態 PDO COB‑ID 變更  
13. 序列圖 C: 晚到高優先級搶占  
14. 狀態機：硬體 RX 綁定生命週期  
15. 日誌事件對照表  
16. 風險與決策節點總攬  
17. 變更記錄  

---
## 1. 圖例與符號說明
| 符號 | 意義 |
|------|------|
| 菱形 | 條件判斷 (是/否分支) |
| 長方形 | 動作/呼叫函式 |
| 圓角矩形 | 外部事件 / 入口點 |
| 子圖 (subgraph) | 週期性或背景程序 |
| 粗體標籤 | 關鍵決策節點 / 風險點 |
| 註解框 (:::note) | Mermaid 中以標準文字行補充 (不使用 classDef 避免 GitHub 相容問題) |

---
## 2. 核心資料結構對照 (摘要)
| 名稱 | 來源 | 角色 |
|------|------|------|
| CO_CANrx_t | CANopenNode | 軟體 RX Buffer, 保存 ident, mask, 回調 |
| g_rxBindings[] | Driver | 映射硬體 RX LMO 使用狀態 (id, score, used, refCount) |
| g_rxLmoIndexMap[] | Driver | 將 DAVE LMO 索引映射到 RX 群組序號與 wildcard |
| g_cobidChanges[] | Driver | 排程中待執行的 COB‑ID 變更/停用 |
| g_wildcardRxIndex | Driver | Wildcard 專用 LMO 索引 (若啟用) |
| g_lastRxMaintainMs | Driver | 上次維護(延遲綁定/搶占)執行時間戳 | 

詳細欄位定義請參考程式碼，本文不重複貼出避免不同步。

---
## 3. 流程 #1 初始化 (CO_CANmodule_init) (Sanitized)
```mermaid
flowchart TD
    A[啟動+DAVE_Init OK] --> B[CO_CANmodule_init]
    B --> C[掃描 LMO 分類 RX/TX]
    C --> D{1 RX + 1 TX 且總數<=2?}
    D -->|YES| E[單一MO模式<br/>g_singleMoMode=true<br/>RX設ID 0x000 軟體過濾]
    D -->|NO| F{是否 >=1 TX 且 RX>=2?}
    F -->|NO| G[退化: 全軟體過濾]
    F -->|YES| H[多RX模式 g_multiRxMode=true]
    H --> I[收集RX索引]
    I --> J[最後一個RX為 wildcard 候選]
    J --> K[減少 g_totalRxLmos (排除 wildcard)]
    K --> L[初始化 g_rxBindings]
    L --> Z[等待 RX 緩衝註冊]
```
備註：Wildcard 可依實測加條件 (例如多於 3 個 RX 時才啟用)。

---
## 4. 流程 #2 RX 緩衝註冊 (CO_CANrxBufferInit) (Sanitized)
```mermaid
flowchart TD
    A[CO_CANrxBufferInit] --> B{singleMoMode?}
    B -->|YES| B1[共用單一RX<br/>軟體過濾] --> R[Return]
    B -->|NO| C{multiRxMode?}
    C -->|NO| C1[退化:軟體過濾] --> R
    C -->|YES| D{ID==0x000?}
    D -->|YES| E{NMT已綁定?}
    E -->|NO| E1[綁定NMT score=4<br/>g_nmtBound=true] --> H
    E -->|YES| E2[軟體過濾 第二個NMT] --> R
    D -->|NO| H[一般綁定]
    H --> I{已有相同ID?}
    I -->|YES| I1[共享 LMO refCount++] --> R
    I -->|NO| J{有空閒RX?}
    J -->|YES| J1[配置硬體 ID mask=0x7FF] --> R
    J -->|NO| K[軟體 fallback]
    K --> L{score>0?}
    L -->|YES| L1[標記 PRIO-DEFER] --> R
    L -->|NO| R
```
Score 規則：NMT=4, SYNC=3, EMCY=2, SDO_RX=1, 其他=0。

---
## 5. 流程 #3 COB-ID 變更 (Sanitized)
### 5.1 排程
```mermaid
flowchart TD
    A[SDO 寫 PDO 通訊參數] --> B{bit31==1?}
    B -->|YES| C[scheduleCobIdDisable] --> E[排入佇列]
    B -->|NO| D[scheduleCobIdChange] --> E
    E --> F[標記 pending]
```
### 5.2 套用 (1ms)
```mermaid
flowchart TD
    T[1ms Timer] --> A[遍歷變更佇列]
    A --> B{pending?}
    B -->|NO| A
    B -->|YES| C[解析 LMO]
    C --> D{TX?}
    D -->|YES| D1{TX 空閒?}
    D1 -->|NO| D2[保留待下次] --> A
    D1 -->|YES| D3[更新ID+Init] --> D4[清 pending] --> A
    D -->|NO| E{disable?}
    E -->|YES| F[RX Disable + dummy 0x7FE + 釋放] --> G[嘗試 Promote] --> H[清 pending] --> A
    E -->|NO| I[RX Disable + 設新ID + Init + Enable]
    I --> J[更新綁定資訊] --> H
```
錯誤保護：解析不到 LMO → 可計數重試，超過閾值打印 `APPLY-RESOLVE-FAIL`。

---
## 6. 流程 #4 綁定釋放與優先級提升 (Sanitized)
```mermaid
flowchart TD
    A[釋放事件] --> B[used=false]
    B --> C[refCount 調整]
    C --> D[promotePriority]
    D --> E{有待提升 高分?}
    E -->|NO| Z[結束]
    E -->|YES| F[挑最高分 或最早等待]
    F --> G[配置 LMO 設ID+mask]
    G --> H[Enable + 更新映射]
    H --> Z
```
若存在複數同分：Tie-break = (1) 等待時間(older) > (2) ID 數值較小。

---
## 7. 流程 #5 延遲維護與搶占 (Sanitized)
```mermaid
flowchart TD
    T[每10ms] --> A[掃描 rxArray]
    A --> B{ident 已確定 且 無 dave_lmo?}
    B -->|NO| A
    B -->|YES| C{已有相同ID硬體?}
    C -->|YES| C1[共享 該 LMO] --> A
    C -->|NO| D{空閒 LMO 存在?}
    D -->|YES| D1[配置 延遲綁定] --> A
    D -->|NO| E{score>0?}
    E -->|NO| A
    E -->|YES| F[找最低分 LMO]
    F --> G{newScore > lowestScore?}
    G -->|NO| A
    G -->|YES| H[搶占 重新配置] --> A
```
建議：之後可將維護頻率自適應化 (負載高時降低頻率)。

---
## 8. 流程 #6 中斷分派 (Sanitized)
```mermaid
flowchart TD
    A[CAN RX IRQ] --> B{multiRxMode?}
    B -->|NO| C[軟體遍歷過濾]
    B -->|YES| D{LMO 綁定且非 wildcard?}
    D -->|YES| E[直接呼叫綁定列表]
    E --> Z[END]
    D -->|NO| F{是否 wildcard?}
    F -->|YES| C
    F -->|NO| G[未知來源 計數]
    G --> Z
    C --> H{軟體比對命中?}
    H -->|YES| E
    H -->|NO| Z
```
潛在優化：為軟體過濾建立哈希/桶分組以降低 O(N)。

---
## 9. 流程 #7 Wildcard 評估與降級 (Sanitized)
```mermaid
flowchart TD
    A[啟用 wildcard] --> B{統計啟用?}
    B -->|NO| Z[直接使用]
    B -->|YES| C[累積 hit 與 rescue]
    C --> D{rescue 比例 > 門檻?}
    D -->|NO| Z[保持]
    D -->|YES| E[降級 停用 wildcard]
    E --> F[回收 LMO]
    F --> Z
```
建議門檻：swRescues / (wildcardHits + 1) > 20%。

---
## 10. 流程 #8 錯誤 / 例外 / 防護 (Sanitized)
```mermaid
flowchart TD
    A[事件分類] --> B{類型}
    B -->|解析失敗| C[RESOLVE-FAIL 重試]
    B -->|TX忙| D[保留 pending]
    B -->|搶占失敗| E[記錄 PREEMPT-NOOP]
    B -->|Wildcard漏收| F[rescue++]
    B -->|重複NMT| G[忽略 NMT-DUP]
    C --> Z
    D --> Z
    E --> Z
    F --> Z
    G --> Z
```

---
## 11. 序列圖 A: 啟動 + 高優先級綁定
```mermaid
sequenceDiagram
    participant APP as Main
    participant DRV as Driver
    participant HW as CAN HW
    APP->>DRV: CO_CANmodule_init()
    DRV->>HW: 掃描 LMO
    DRV-->>APP: 模式=multiRx
    loop 註冊 NMT / SYNC / EMCY
        APP->>DRV: CO_CANrxBufferInit(ID)
        DRV->>HW: 配置硬體 (若未使用)
        DRV-->>APP: 返回 (包含 dave_lmo)
    end
```

## 12. 序列圖 B: 動態 PDO COB‑ID 變更
```mermaid
sequenceDiagram
    participant TOOL as ConfigTool
    participant SDO as SDO Server
    participant DRV as Driver
    participant HW as CAN HW
    TOOL->>SDO: Write 0x1400:1 newCobId
    SDO->>DRV: scheduleCobIdChange(old,new)
    Note over DRV: 佇列 pending=true
    loop 每 1ms
        DRV->>DRV: applyCobIdChanges()
        alt RX 項目
            DRV->>HW: DisableRxEvent
            DRV->>HW: Set New ID + Init + Enable
            DRV->>DRV: 更新 g_rxBindings
        else TX 項目
            DRV->>DRW: 檢查 TX 空閒後更新
        end
    end
```

## 13. 序列圖 C: 晚到高優先級搶占
```mermaid
sequenceDiagram
    participant L as LowPrio PDOs
    participant H as HighPrio (SDO_RX)
    participant DRV as Driver
    participant HW as CAN HW
    L->>DRV: 多個低分 ID 註冊 (占滿硬體)
    H->>DRV: 註冊 (fallback 軟體)
    Note over DRV: 標記 RX-PRIO-DEFER
    DRV->>DRV: maintainRxBindings() 10ms
    DRV->>DRV: 找最低 score 綁定
    DRV->>HW: 搶占 Disable→改 ID→Init→Enable
    DRV->>DRV: 更新 g_rxBindings & rxArray.dave_lmo
    H-->>DRV: 之後接收走硬體快路徑
```

---
## 14. 狀態機：硬體 RX 綁定生命週期
```mermaid
stateDiagram-v2
    [*] --> UNUSED
    UNUSED --> BOUND : 新 ID 綁定 (Init+Enable)
    BOUND --> SHARED : 第二個同 ID buffer 註冊
    SHARED --> SHARED : 更多同 ID buffer
    BOUND --> PREEMPT_CANDIDATE : 高分待搶占檢查
    SHARED --> PREEMPT_CANDIDATE : 若全部 refCount 轉移或降低
    PREEMPT_CANDIDATE --> UNUSED : Disable + 釋放 + 更新表
    PREEMPT_CANDIDATE --> BOUND : 被更高分占用後重新分配
    BOUND --> UNUSED : disable / COB-ID 移除
    SHARED --> UNUSED : 所有共享釋放 / disable
```

---
## 15. 日誌事件對照表 (示例)
| 日誌 Tag | 觸發場景 | 代表處理 | 常見後續 |
|---------|----------|----------|----------|
| RX-BIND | 初次硬體綁定成功 | 建立 BOUND | 穩定接收 |
| RX-PRIO-DEFER | 高分 ID 無硬體可用 | 等待維護/釋放 | 維護後可能 BIND |
| RX-PREEMPT | 低分被搶占 | LMO 重新配置 | 高分進硬體 |
| RX-SHARE | 同 ID 第二個 buffer | refCount++ | SHARED 狀態 |
| RX-REL | ID disable 或變更 | 釋放 LMO | 觸發 promote |
| APPLY-RESOLVE-FAIL | COB-ID 變更解析不到 LMO | 重試計數 | 逾時報警 |
| NMT-DUP | 第二個 0x000 嘗試硬體綁定 | 改軟體過濾 | 無 |
| WILDCARD-DISABLE | 降級策略觸發 | 回收 wildcard | 增加可分配數 |
| PREEMPT-NOOP | 欲搶占但無更低分 | 保持原狀 | 可能日後重試 |

---
## 16. 風險與決策節點總攬
| 節點 | 風險 | 緩解 |
|------|------|------|
| Wildcard | 硬體不支援全覆蓋 | 統計+降級機制 |
| 搶占判斷 | 誤搶造成延遲高 | 僅 newScore>oldScore 且非 NMT 固定 |
| 動態變更 | TX 正在傳送時切換 | 檢查 pending/Busy 重試 |
| 多 0x000 | 浪費硬體 | 單次硬體綁定限制 |
| 過多日誌 | UART 壅塞 | 節流旗標 + 分級開關 |
| 維護頻率 | 過慢=高分延遲 | 可調參數 / 自適應策略 |

---
## 17. 變更記錄
| 版本 | 日期 | 說明 |
|------|------|------|
| 1.0 | 2025-08-30 | 初版 (簡化 5 流程) |
| 2.0 | 2025-08-30 | 全面擴充：8 流程 + 3 序列 + 狀態機 + 日誌對照 |

---
> 若需導出 PDF 或加入程式碼行號對照 (行號 map 到 `CO_driver_XMC4800.c`), 可再提出需求。

EOF
